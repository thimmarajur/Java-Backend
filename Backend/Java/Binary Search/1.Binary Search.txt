//Normal Search    
public static int binarySearch(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		if(target==arr[mid]) {
    			return mid;
    		}else if(target>arr[mid]) {
    			left = mid+1;
    		}else {
    			right=mid-1;
    		}
    		
    	}
    	
    	return -1;
    	
    }


-------------------------------------------------------------------------------------------------------
//Normal Search with Duplicates First Occurance
    
public static int firstOccurance(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		if(target==arr[mid]) {
    			result = mid;
    			right = mid-1;
    		}else if(target>arr[mid]) {
    			left = mid+1;
    		}else {
    			right=mid-1;
    		}
    		
    	}
    	
    	return result;
    	
    }

-------------------------------------------------------------------------------------------------------
//Normal Search with Duplicates Last Occurance
    
public static int lastOccurance(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		if(target==arr[mid]) {
    			result = mid;
    			left = mid+1;
    		}else if(target>arr[mid]) {
    			left = mid+1;
    		}else {
    			right=mid-1;
    		}
    		
    	}
    	
    	return result;
    	
    }


-------------------------------------------------------------------------------------------------------
//Insert Position / with Duplicates

public static int insertPosition(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		if(target==arr[mid]) {
    			return mid;
    		}else if(target>arr[mid]) {
    			result =mid+1;
    			left = mid+1;
    		}else {
    			result =mid;
    			right=mid-1;
    		}
    		
    	}
    	
    	return result;
    	
    }


-------------------------------------------------------------------------------------------------------
//Search In Rotated Array

    
public static int searchInRotatedArray(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		if(target==arr[mid]) {
    			return mid;
    		}
    		
    		if(arr[mid]<arr[right]) { //right is sorted
    			if(target>arr[mid] && target<=arr[right]) {
    				left = mid+1;
    			}else {
    				right = mid-1;
    			}
    		}else { //left is sorted
    			if(target<arr[mid] && target>=arr[left]) {
    				right = mid-1;
    			}else {
    				left = mid+1;
    			}
    		}
    		
    	}
    	
    	return -1;
    	
    }



-------------------------------------------------------------------------------------------------------
//Search In Rotated Array With Duplicates First Occurance

public static int searchInRotatedArrayWithDupFirstOccu(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		
    		if(arr[left] == target && arr[left]==arr[mid] && arr[mid]==arr[right]) {
    			return left;
    		}
    		if(target==arr[mid]) {
    			result = mid;
    			right=mid-1;
    		}else if(arr[mid]<arr[right]) { //right is sorted
    			if(target>arr[mid] && target<=arr[right]) {
    				left = mid+1;
    			}else {
    				right = mid-1;
    			}
    		}else { //left is sorted
    			if(target<arr[mid] && target>=arr[left]) {
    				right = mid-1;
    			}else {
    				left = mid+1;
    			}
    		}
    		
    	}
    	
    	return result;
    	
    }


-------------------------------------------------------------------------------------------------------
//Search In Rotated Array With Duplicates Last Occurance

    public static int searchInRotatedArrayWithDupLastOccu(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =-1;
    	while(left<=right) {
    		int mid = left + (right - left) / 2;
    		
    		if(arr[left] == target && arr[left]==arr[mid] && arr[mid]==arr[right]) {
    			return right;
    		}
    		if(target==arr[mid]) {
    			result = mid;
    			left=mid+1;
    		}else if(arr[mid]<arr[right]) { //right is sorted
    			if(target>arr[mid] && target<=arr[right]) {
    				left = mid+1;
    			}else {
    				right = mid-1;
    			}
    		}else { //left is sorted
    			if(target<arr[mid] && target>=arr[left]) {
    				right = mid-1;
    			}else {
    				left = mid+1;
    			}
    		}
    		
    	}
    	
    	return result;
    	
    }



-------------------------------------------------------------------------------------------------------
//Min In Rotated Sorted Array


public static int minInRotatedSortedArr(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =right;
    	 while (low < high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] > nums[high]) {
                // Minimum is in the right half
                low = mid + 1;
            } else {
                // Minimum is in the left half (including mid)
                high = mid;
            }
        }
    	
    	return arr[result];
    	
    }



-------------------------------------------------------------------------------------------------------
//Max In Rotated Sorted Array

    
public static int maxInRotatedSortedArr(int[] arr,int target) {
    	
    	int left = 0,right = arr.length-1;
    	int result =right;
    	 while (low < high) {
            int mid = low + (high - low + 1) / 2;
            
            if (nums[mid] > nums[0]) {
                // Max is to the right of or at mid
                low = mid;
            } else {
                // Max is to the left
                high = mid - 1;
            }
    	
    	return arr[result];
    	
    }


-------------------------------------------------------------------------------------------------------
// Peak Index in a Mountain Array {0, 2, 4, 6, 5, 3, 1}


    public static int peakIndexInMountainArray(int[] nums) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] < nums[mid + 1]) {
                // We're in the ascending part of the mountain
                left = mid + 1;
            } else {
                // We're in the descending part or at the peak
                right = mid;
            }
        }

        // left == right is the peak index
        return left;
    }


-------------------------------------------------------------------------------------------------------