1. Checked vs. Unchecked exceptions ‚Äì what‚Äôs the difference?
	
	In Java, exceptions are categorized into two main types: checked exceptions and unchecked exceptions. The key difference between them lies in how they are enforced by the compiler and their intended use cases. Here's a detailed explanation:

	a. Checked Exceptions
		Definition: Checked exceptions are exceptions that the compiler requires you to handle explicitly. They represent conditions that a well-written application should anticipate and recover from.

		Examples:

			IOException (e.g., file not found, network issues).

			SQLException (e.g., database access errors).

			ClassNotFoundException (e.g., class not found at runtime).

		Characteristics:

			Compiler Enforcement: The compiler checks that these exceptions are either:

			Caught using a try-catch block.

			Declared in the method signature using the throws keyword.

			Recoverable: Checked exceptions typically represent scenarios where recovery is possible (e.g., retrying a file operation or notifying the user).

			Usage: Used for scenarios where the application can reasonably be expected to handle the exception.
			
			
	b. Unchecked Exceptions
		Definition: Unchecked exceptions are exceptions that the compiler does not require you to handle explicitly. They represent programming errors or runtime conditions that are usually not recoverable.

		Examples:

			NullPointerException (e.g., accessing a null object).

			ArrayIndexOutOfBoundsException (e.g., accessing an array beyond its bounds).

			ArithmeticException (e.g., division by zero).

		Characteristics:

			No Compiler Enforcement: You are not required to catch or declare unchecked exceptions.

			Runtime Errors: These exceptions typically indicate bugs in the code (e.g., logic errors, invalid assumptions).

			Usage: Used for scenarios where the application cannot reasonably recover (e.g., programming errors).
			
			
	When to Use Which
		Checked Exceptions:

			Use for conditions that a well-written application should anticipate and handle (e.g., file I/O, network issues).

			Encourage robust error handling and recovery.

		Unchecked Exceptions:

			Use for programming errors or conditions that are not expected to be recoverable (e.g., null pointers, invalid arguments).

			Indicate bugs that need to be fixed in the code.

	Best Practices
		Checked Exceptions:

			Handle exceptions gracefully (e.g., log the error, retry the operation, or notify the user).

			Avoid overusing checked exceptions for conditions that are not truly recoverable.

		Unchecked Exceptions:

			Use for programming errors that should be fixed during development.

			Avoid catching unchecked exceptions unless you have a specific recovery strategy.
			
			
	Summary
		Checked Exceptions: Represent recoverable conditions; must be handled explicitly.

		Unchecked Exceptions: Represent programming errors; not required to be handled.

		Use checked exceptions for anticipated, recoverable scenarios and unchecked exceptions for unexpected, unrecoverable errors. Understanding the difference helps you write more robust and maintainable code.


2.	Global Exception Handling

	**Global Exception Handling** is a centralized mechanism for managing exceptions that occur anywhere in an application, preventing the application from crashing and ensuring consistent, user-friendly error responses.

	In large applications, especially REST APIs built with **Spring Boot**, handling exceptions within every controller's method (`try-catch` blocks) leads to code duplication and inconsistency. Global exception handling solves this by delegating all unhandled exceptions to a single, central class.

	-----

	### How Global Exception Handling Works in Spring Boot

	Spring Boot provides two primary annotations to implement centralized exception handling for web applications (REST APIs):

	1.  **`@ControllerAdvice`**: This annotation marks a class as a global exception handler. It allows the class to "advise" all controllers in the application, making its handler methods applicable application-wide.

		  * For REST APIs, you often use the specialized **`@RestControllerAdvice`**, which is essentially `@ControllerAdvice` + `@ResponseBody`, ensuring that the response object is automatically converted to JSON/XML.

	2.  **`@ExceptionHandler`**: This annotation is used inside the `@ControllerAdvice` class on a method. It maps a specific **exception type** (e.g., `ResourceNotFoundException.class`) to the method that should handle it.

	-----

	### üõ†Ô∏è Implementation Example

	A typical global exception handler class looks like this:

	```java
	import org.springframework.http.HttpStatus;
	import org.springframework.http.ResponseEntity;
	import org.springframework.web.bind.annotation.ControllerAdvice;
	import org.springframework.web.bind.annotation.ExceptionHandler;

	// Use @RestControllerAdvice if building a pure REST API
	@ControllerAdvice 
	public class GlobalExceptionHandler {

		// 1. Handler for a Custom Exception
		@ExceptionHandler(ResourceNotFoundException.class)
		public ResponseEntity<ErrorDetails> handleResourceNotFoundException(ResourceNotFoundException ex) {
			// Create a structured error response object
			ErrorDetails error = new ErrorDetails(
				HttpStatus.NOT_FOUND.value(), 
				ex.getMessage(), 
				System.currentTimeMillis()
			);
			// Return a response entity with the desired HTTP status
			return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
		}

		// 2. Handler for a Generic/Catch-All Exception
		@ExceptionHandler(Exception.class)
		public ResponseEntity<ErrorDetails> handleGlobalException(Exception ex) {
			ErrorDetails error = new ErrorDetails(
				HttpStatus.INTERNAL_SERVER_ERROR.value(),
				"An unexpected error occurred: " + ex.getMessage(),
				System.currentTimeMillis()
			);
			// Returns HTTP 500 (Internal Server Error)
			return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
	```

	In your Controller method, you simply throw the exception, and the global handler automatically catches it:

	```java
	@RestController
	@RequestMapping("/api/users")
	public class UserController {
		@GetMapping("/{id}")
		public User getUser(@PathVariable long id) {
			User user = userService.findById(id); 
			
			if (user == null) {
				// Throwing the exception directly
				throw new ResourceNotFoundException("User not found with ID: " + id);
			}
			return user;
		}
	}
	```


					// Simple POJO class to structure the error response
			class ErrorResponse {
			    private int status;
			    private String message;
			    
			    // Constructor, Getters, Setters
			    // ...
			}
			
			// A simple custom exception (e.g., when a DB record isn't found)
			class ResourceNotFoundException extends RuntimeException {
			    public ResourceNotFoundException(String message) {
			        super(message);
			    }
			}

	### Key Benefits

	  * **Centralization**: All exception-handling logic is in one place, making it easy to manage and update.
	  * **Consistency**: Ensures that all API error responses follow a uniform format (e.g., a standard JSON structure with `status`, `message`, and `timestamp`).
	  * **Decoupling**: Separates the **error-handling logic** from the **business logic** in your controllers and services, resulting in cleaner, more readable code.




3.	A ClassCastException is a common type of runtime error in object-oriented programming languages like Java and Kotlin. It occurs when 	you try to cast an object of one type to a type that it is not an instance of or a subclass of.

		Here's a breakdown of what it means and why it happens:
		
		üßê What is a Cast?
		A "cast" is an operation that tells the compiler to treat an object of one type as if it were a different type.
		
		Upcasting (Safe): Casting a subclass object to its superclass type. This is always safe and happens implicitly.
		
		Example: Casting a Dog object to an Animal reference.
		
		Downcasting (Potentially Unsafe): Casting a superclass object back down to a subclass type. This requires an explicit cast and is where the ClassCastException occurs if you're wrong.
		
		Example: Casting an Animal reference back to a Dog reference.
		
		üí• When Does the Exception Occur?
		The exception happens specifically during downcasting when the object you are trying to cast does not have the actual type you are casting it to.
		
		Scenario Example (in Java-like pseudocode):
		Imagine you have two classes, Cat and Dog, both of which inherit from a superclass Animal.
		
		Java
		
				// 1. Create a Cat object, but hold it in an Animal reference (Upcasting)
				Animal myAnimal = new Cat(); 
				
				// This is safe. The actual object is a Cat.
				// 
				
				// 2. Try to cast the Animal reference to a Dog (Downcasting)
				Dog myDog = (Dog) myAnimal; // <-- THIS CAUSES ClassCastException
		
		// Reason: The variable myAnimal *actually* holds a Cat object at runtime, 
		// and a Cat object cannot be treated as a Dog object (they are siblings, not parent/child).
		üí° How to Prevent It
		You can prevent ClassCastException by checking the object's actual type before attempting the downcast.
		
		Using instanceof (Java):
		
		Java
		
				if (myAnimal instanceof Dog) {
				    Dog myDog = (Dog) myAnimal; // Cast is now safe
				    // ... use myDog
				} else {
				    // Handle the case where it's not a Dog (it's a Cat, etc.)
				}



